// to be Used with VU3wjm Lagoon rig : use Arduino Genuino Uno, works for bitx too by selecting appropriate defines.
//-----------------------------
// Ver V3.4Cd iintroducing keypad calib and automatic values calculation for various switch presses. Also added Encoder based step size change two key kpd
// Ver "V3.4Cc" separated the freq setting routines from loop (will help in changing the logic of vfo/bfo generation)
/// tbd frq correcn, key allocation for long press, RIT(needs PTT input)
// also added separate entries for 2 bander bitx 13/5/2021 sub ver no a (3.4Ca)
// xtl freq correction , (3.4Cb)  17/76/2021
// Ver 3.4C included offset adjustment on long press vfo key 4 19/5/2020
// Ver 3.4B 3/10/19 added [ && ( millis() - entryTime) >= 5000) and error output ] in read kpd for it as blocking
// when input was open / bad soldering
//Ver 3.4A 19/5/19 IF saving was left out so added (Pointed by Mr Sampath)
//Ver 3.4 3/9/18, saving BFOs and VFOs , if mem content is different. In VFO display added offset, filter selection
//Ver 3.3 corrected mem display/band change problem (26/8/18), Ver# display on start
//Ver3.2 17/8/18 : corrected VFO/BFO name display problem when changing BFO, setting limits in band in VFO, display format
//Ver3.1 with PTT in/out
//Ver 3.0 4/8/18 Cursor underline instead of step size, S-meter
//Ver 2.1 3/8/18 - 7 Analog keys on A0 (1K between keys and to gnd, 10k to +5 from common pins of keys)
// ver 2.0 added Vfos/mem, store fn
// version 0.1 //29/7/2018 basic vfo bfo display & change,
// ver 0.2 29/7/2018 mem limits, added BC band
//
// Hardware note: if A0 is open then the display will not change by encoder or kpd
// Logic: Output freq = vfo freq - bfo freq +/- mode offset freq
// mode freq for USB = 1500 Hz , LSB = -1500 Hz,
// eg for 7000.00 kHz LSB = 17 MHz (vfo) - 10MHz (bfo) + (-1500 Hz) ??
// for 14200.00 kHz USB = 4.20 Mhz (vfo) + 10MHz(bfo) + 1500 Hz

//****** Check the xtal freq connected to Si5351 and select below.

#define bitx  // *****
//#define lagoon
#include <Rotary.h>  // Ben Buxton's Rotary Library
#include <si5351.h>  // Etherkit - NT7S Library
#include <Wire.h>
#include <LiquidCrystal.h>
#include "EEPROMAnything.h"

#if defined lagoon
#include <LcdBarGraph.h>
LcdBarGraph smeter(&lcd, 6, 10, 1);  // 6chars wide, 11th col  top row
#endif

#define Ver "V3.4Cd"
// added 2 button and encoder based step change also
// Hardware connections
#define ENCODER_A 2   // Encoder pin A on Mega A10- others D2
#define ENCODER_B 3   // Encoder pin B on Mega A11- others D3
#define EncoderBtn 4  // Switch on Encoder
#define PTT_IN A3     // PTT input
#define PTT_OUT A3;   // output to  PTT relay (D17)

// band switching connection defined later
#define LCD_RS 8
#define LCD_E 9
#define LCD_D4 10
#define LCD_D5 11
#define LCD_D6 12
#define LCD_D7 13
//--------------------

LiquidCrystal lcd(LCD_RS, LCD_E, LCD_D4, LCD_D5, LCD_D6, LCD_D7);  // LCD - pin assignement
Si5351 si5351;
Rotary r = Rotary(ENCODER_A, ENCODER_B);

//===INITIAL startup values
uint32_t opfreq = 0UL;                                               // Operating freq to be generated by Si5351 feeding to VFO input
boolean changed_f = 0, changed_b = 0, changed_m = 0, changed_o = 0;  // flags to indicate changes - taken care in loop
uint32_t correction = 0;                                             //1500;// freq correction depends on Si5351 etc
boolean setbfo = false;                                              //  tuning bfo flag
boolean setOffset = false;                                           // band offsets
int16_t enc_cnt = 0, prev_enc_cnt = 0;                               //encoder count
boolean encoder_change = 0;                                          // if encoder rotated
uint8_t activeCh = 1;                                                // currently selected  channel 1 onwards (not from 0)
uint8_t memChMode = 0;                                               // 0=VFO A/b, 1 changed to Mem , 2 within Mem channel number changes
#define smIn A2                                                      // smeter in A2
#define PTT_OUT A3;                                                  // output to  PTT relay
bool inTx = 0;                                                       // high when in Tx mode
bool btnPressed = false;                                             // When encoder btn remains pressed

//======================

//String VFO_Names[] = {"A", "B", "M"};   // short forms if needed
String VFO_Names[] = { "VFOA", "VFOB", "M   " };

uint8_t activeVFO = 0;                                       //select 0 / 1 / 2 for A / B / M
uint32_t VFO_Freq[] = { 7050000UL, 14200000UL, 7050000UL };  //21060000UL}; // initial freqs for three VFO's

// ----------- band inits some of these may be country / region specific, adjust accordingly
#ifdef bitx
// bitx 2 bander  - modify below for more bands available in HW as in #else clause below
uint8_t maxBands = 2;
char* BandNames[] = { "40m", "20m" };  // needed only if band names are to be displayed, not used now v2.1
uint8_t Bands[] = { 40, 20 };
uint32_t BandBases[] = { 7000000UL, 14000000UL };     // Band bottom freq
uint32_t BandTops[] = { 7200000UL, 14350000UL };      // Band highest freq
uint32_t BandWkgFreqs[] = { 7050000UL, 14200000UL };  // working freq first time
uint8_t bindex = 0;                                   // Band Index - on startup 40 m selected
uint32_t vfo = BandWkgFreqs[bindex];                  //initial freq - change to suit
int32_t BandOffset[] = { 0, 0 };                      // offsets for each band  - adjustable by long press key 4
uint8_t BandSelPins[] = { 5, 6 };                     // for 40, 20 m separate / or only one pin may be sufficient for 2 bands

uint8_t const maxModes = 2;
int32_t mode_offset[2] = { 1500, -1500 };  //** BFO Offsets for CW, USB, LSB and 0 for BC band (offset from IF)
String mode_name[2] = { "LSB", "USB" };
//{"C", "U", "L", "B"}; // if space limited
uint8_t mode = 0;  // 0= LSB, 1= USB

#else
// for other multi band systems
uint8_t maxBands = 4;
char* BandNames[] = { "40m", "20m", "15m", "BC" };  // needed only if band names are to be displayed, not used now v2.1
uint8_t Bands[] = { 40, 20, 15, 00 };
uint32_t BandBases[] = { 7000000UL, 14000000UL, 21000000UL, 1000000UL };      // Band bottom freq
uint32_t BandTops[] = { 7200000UL, 14350000UL, 21450000UL, 30000000UL };      // Band highest freq
uint32_t BandWkgFreqs[] = { 7065000UL, 14200000UL, 21060000UL, 15000000UL };  // working freq first time
uint8_t bindex = 0;                                                           // Band Index - on startup 40 m selected
uint32_t vfo = BandWkgFreqs[bindex];                                          //initial freq - change to suit
int32_t BandOffset[] = { 0, 0, 0, 0 };                                        // offsets for each band  - adjustable by long press key 4
uint8_t BandSelPins[] = { 5, 6, 7, 5 };                                       // for 40, 20, 15 m - ?? BC temp same as 40 m selected

uint8_t const maxModes = 4;
int32_t mode_offset[4] = { 700UL, 1500UL, -1500UL, 0UL };  //** BFO Offsets for CW, USB, LSB and 0 for BC band (offset from IF)
String mode_name[4] = { "CW ", "USB", "LSB", "BC " };
//{"C", "U", "L", "B"}; // if space limited
uint8_t mode = 2;  // 0=CW, 1= USB, 2= LSB, 3 = BC

#endif

// Side band / mode

int32_t bfo;
// Board or Hardware Dependent params
#if defined lagoon
int32_t if_freq = 12000000UL;  // 12 MHz IF - BFO
#endif

// OR
#if defined bitx
int32_t if_freq = 9996000UL;  // Bitx 10MHz IF / Actual may be about 9997000 (LSB) 9994000 (USB)
#endif

//uint32_t xtal_frequency = 0; // For a 25MHz xtal on 5351 ********
//OR
//uint32_t xtal_frequency = 27000000; // some boards have it  ********** eg one in aluminum box small
//OR
//uint32_t xtal_frequency = 25004500;  // eg as measured by Dan Cantrel calibration1 prog for board#2021-01
//uint32_t xtal_frequency = 25005400;  // eg as measured by Dan Cantrel calibration1 prog for board#2021-02
uint32_t xtal_frequency = 25004530;  // eg as measured by Dan Cantrel calibration1 prog for board#2020-02

// for bitx LSB @7050kHz vfo should be ~17044xxkHz and bfo ~9997xxkHz using addition
// for USB BFO ~9994xx kHz vfo ~17044xx

// *** if this xtal_freq is wrongly selected there will not be any output at the IF xtal filter (since input is not 10MHz)

//------
const uint8_t number_of_keys = 8;
int8_t stepzIndex = 3;                                                                                 // initial setting 1000 Hz step change
uint32_t stepz[number_of_keys] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000 };               // freq change steps
String stepzStr[number_of_keys] = { "   1", "  10", " 100", "  1k", " 10k", "100k", "  1M", " 10M" };  // to be displayed steps
String keymap[number_of_keys] = { "save", "BFO", "SB", "BAND", "VFO", "<", ">" };
uint16_t keyPad[number_of_keys] = { 405, 375, 325, 275, 220, 158, 83 };  // analogread keypadvalues for board#2021-01 (left to right) - reduced by a few counts (~5) from actual

uint8_t vfoPosn = 3;  // column where the vfo/bfo will be displayed
//uint16_t keyPad[] = {415, 375, 335, 285, 230, 160, 85};  // analogread keypadvalues (left to right) - reduced by a few counts (~5) from actual
// the keypad voltages may vary from board to board due to variations in Resistors.

uint16_t keyVal, keyVal2;
uint32_t buttonPressTime, entryTime;
bool longPress;
uint8_t curPos;  // underscore cursor position
// MEMORY Map in EEPROM of CPU: Magic No, A, B, Mem 1,2,3...20, each of sizeof(vfo) bytes (int 32)
//***********
uint8_t magic_no = 3;  // ver & written to EEPROM identifier ***********
//***********
uint16_t magic_no_addr = 00;
uint16_t VFO_A_addr = magic_no_addr + sizeof(magic_no);
uint16_t VFO_B_addr = VFO_A_addr + sizeof(vfo);
uint16_t IF_addr = VFO_B_addr + sizeof(vfo);
uint16_t CWOffset_addr = IF_addr + sizeof(vfo);
uint16_t USBOffset_addr = CWOffset_addr + sizeof(bfo);
uint16_t LSBOffset_addr = USBOffset_addr + sizeof(bfo);
uint16_t BCOffset_addr = LSBOffset_addr + sizeof(bfo);
uint16_t BandOffset0_addr = BCOffset_addr + sizeof(BandOffset[0]);  // individual band offsets from ver 3.4c
uint16_t BandOffset1_addr = BandOffset0_addr + sizeof(BandOffset[0]);
uint16_t BandOffset2_addr = BandOffset1_addr + sizeof(BandOffset[0]);
uint16_t BandOffset3_addr = BandOffset2_addr + sizeof(BandOffset[0]);
uint16_t VFO_M_base_addr = BandOffset3_addr + sizeof(bfo);        // from here onwards all 20 mem ch data stored
uint16_t key_pad_base_addr = VFO_M_base_addr + 20 * sizeof(bfo);  // from emd of mem the keypad values will be stored

int32_t x;  // temp var
uint16_t max_mem_ch = 20;
int count = 0;
//-------


void setup() {
  //--- encoder interrupt vector
  PCICR |= (1 << PCIE2);  //  Enable pin change interrupt for the encoder
  // In Mega PCINT 18/19 are A10, A11
  PCMSK2 |= (1 << PCINT18) | (1 << PCINT19);  // Change interrupts 18 and 19 correspond to A10,A11 on Mega
  // on ATMega386 these are D2 and D3
  sei();
  //---


  Serial.begin(9600);  // for test

  lcd.begin(16, 2);  // Initialize and clear the LCD
  lcd.clear();
  Wire.begin();
  lcd.print("Ver: ");
  lcd.print(Ver);
  delay(1000);
  lcd.clear();


  //initialize the vfo at CLK 0  on Si5351
  si5351.init(SI5351_CRYSTAL_LOAD_8PF, xtal_frequency, correction);  //If you're using a 27Mhz crystal, put in 27000000 instead of 0 in second argument
  // 0 is the default crystal frequency of 25Mhz. in some simple dds boards it may be 27MHz xtal
  // or as measured using Dan Cantrel's calibration1 prog.

  // if needed use one of these
  //si5351.drive_strength(SI5351_CLK0,SI5351_DRIVE_2MA); //you can set this to 2MA, 4MA, 6MA or 8MA
  //si5351.drive_strength(SI5351_CLK1,SI5351_DRIVE_2MA); //be careful though - measure into 50ohms
  //si5351.drive_strength(SI5351_CLK2,SI5351_DRIVE_2MA); //
  pinMode(EncoderBtn, INPUT_PULLUP);
  pinMode(PTT_IN, INPUT_PULLUP);      //for PTT input
  for (int i = 0; i < maxBands; i++)  // deactivate all Band select pins
  {
    pinMode(BandSelPins[i], OUTPUT);
    digitalWrite(BandSelPins[i], LOW);
  }

  digitalWrite(BandSelPins[bindex], HIGH);  // select default band
  //fill_keypad();
  // keypad calibration is invoked by keeping the ">" (rightmost) key pressed while applying power
  if (analogRead(0) < 100)  // ">" key pressed at powerup
    keyCal();               // from ver 3.4Cd

  if (EEPROM.read(magic_no_addr) != magic_no)
    init_eprom();  // if blank eeprom or changed/new magic_no for reinit

  read_eprom();  // get infos of VFO A & B and mem ch 1

  bfo = if_freq + mode_offset[mode];
  opfreq = vfo + bfo + BandOffset[bindex];

  set_vfo_freq();
  set_bfo_freq();
  display_mode();
  display_vfo_name();
  display_stepz();
  set_filter();
  //  Serial.println("end of Setup");
}

void change_step_size() {
  if (enc_cnt > prev_enc_cnt)
    incr_step();
  else
    decr_step();
  prev_enc_cnt = enc_cnt;
}

void loop() {
  //detect PTT press and take action.

  if (encoder_change) {
    if (btnPressed)
      change_step_size();
    else if (setbfo)
      set_bfo_freq();
    else if (setOffset)
      set_offset();
    else
      set_vfo_freq();

    encoder_change = false;
  }
  // Update the display if the frequency (vfo or bfo) is changed
  if (changed_f)
    adj_vfo_freq();  //since Ver "V3.4Cc"

  if (changed_b)
    adj_bfo_freq();  // since Ver "V3.4Cc"

  if (changed_m)  // memory ch changed
  {
    display_ch();
    changed_f = true;
    changed_m = false;
  }

  if (setOffset) {
    display_vfo_bfo();
    changed_f = true;
    changed_o = false;
  }
  read_keypad();  // this is blocking if the input A0 is open or short to ground so timer used

  if (!PTT_IN)  // Pushed PTT button to ground ??
  {
    inTx = 1;
  } else {
    inTx = 0;
  }
  display_TxRx();

  display_stepz();  // for underline cursor
#if defined lagoon
  if ((count % 10) == 0)  // display s meter every 10th count
  {
    display_s_meter();
  }
  count++;
#endif

  delay(10);  // to stop multiple triggering  old val 50
}



/**************************************/
/* Interrupt service routine for      */
/* encoder frequency change           */
/**************************************/
ISR(PCINT2_vect) {
  unsigned char result = r.process();
  if (result == DIR_CW)
    enc_cnt = +1;
  else if (result == DIR_CCW)
    enc_cnt = -1;
  encoder_change = true;
}

void read_keypad() {
  keyVal = analogRead(A0);
  if (keyVal > 1000)  // all keys open (was 1000 but board #2020-02 has lower value so reduced to 980)
    return;

  keyVal = analogRead(A0);  // read again for confirmation
  entryTime = millis();
  delay(100);  // debounce time
  keyVal2 = analogRead(A0);

  while (analogRead(A0) <= 1000 && (millis() - entryTime) <= 5000)
    ;  // wait till key is released or 5 sec- to be tested

  if ((millis() - entryTime) >= 5000)  // either pressed or wiring problem (eg wire is open at A0 )
  {
    lcd.clear();
    lcd.setCursor(3, 0);
    lcd.print("Keypad Error");
    return;
  }

  if ((millis() - entryTime) >= 1000)  // pressed for > 1 sec
    longPress = 1;
  else
    longPress = 0;

  /* if (abs(keyVal2 - keyVal) >= 20 ) // diff in two reads not matched was creating problen in one of the boards so commented out
       return;
  */
  if (!longPress)  //short momentary press
  {
    if (keyVal2 > keyPad[0])  // save currently selected VFO freq and other parameters in EEPROM
      save_vfo();

    else if (keyVal2 > keyPad[1])  //  tune bfo  -- may be shfted to a long press and A<>B vfo exchange here or next to vfo key
    {
      setbfo = !setbfo;
      changed_b = 1;
    }

    else if (keyVal2 > keyPad[2])  // sideband/mode change CW/USB/LSB/BC in sequence
      select_sideband();

    else if (keyVal2 > keyPad[3])  // band select 40/20/15
      select_band();

    else if (keyVal2 > keyPad[4])  // active vfo A/B/M
      select_vfo();

    else if (keyVal2 > keyPad[5])  // increase step size
      incr_step();

    else if (keyVal2 > keyPad[6])  // decrease step size
      decr_step();
  } else  // longPress
  {
    if (memChMode)  // only if in mem ch mode
    {
      if (keyVal2 > keyPad[5])  // > key then incr mem channel
        incr_mem_ch();

      else if (keyVal2 > keyPad[6])  // <  Decr mem ch
        decr_mem_ch();
    } else if (keyVal2 > keyPad[4] && keyVal2 < keyPad[3])  // set offset by long press of VFO button
    {
      setOffset = !setOffset;
      changed_o = setOffset;
    }
    longPress = 0;
  }
}


void set_filter()  // select the output pin for filter selection
{
  for (int i = 0; i < maxBands; i++)  // deactivate all Band select pins
  {
    pinMode(BandSelPins[i], OUTPUT);
    digitalWrite(BandSelPins[i], LOW);
  }

  digitalWrite(BandSelPins[bindex], HIGH);  // select  band
}



void decr_step()  //
{
  stepzIndex -= 1;
  if (stepzIndex < 0)
    stepzIndex = 7;
  display_stepz();
}

void decr_mem_ch()  // long press <
//  else   //in Mem mode
{
  activeCh += 1;
  if (activeCh > max_mem_ch)
    activeCh = 1;
  display_ch();
  memChMode = 2;  // now in mem mode first time needed
  read_ch(activeCh);
  vfo = VFO_Freq[activeVFO];
  set_filter();
  display_vfo_bfo();
}


void incr_step() {
  stepzIndex += 1;
  if (stepzIndex > 7)
    stepzIndex = 0;
  display_stepz();
}


void incr_mem_ch()  // long press >
{
  //  else
  {
    activeCh -= 1;
    if (activeCh <= 0)
      activeCh = max_mem_ch;
    display_ch();
    memChMode = 2;  // now in mem mode first time needed
    read_ch(activeCh);
    vfo = VFO_Freq[activeVFO];
    display_vfo_bfo();
    set_filter();
  }
}


//--------------------------


/*void set_Ch()
  {
  activeCh += enc_cnt;
  if (activeCh > max_mem_ch)
    activeCh = 1;
  if (activeCh <= 0)
    activeCh =  max_mem_ch;
  enc_cnt = 0;
  changed_m = 1;
  }*/

//-----------------------